# generated by gemini

import pytest
from pathlib import Path

# We will reuse the setup from test_expNote to create a realistic environment
from .test_expNote import exp_note_setup
from ammonkey.core.sync import VidSynchronizer, SyncConfig
from ammonkey.core.expNote import ExpNote, Task
from ammonkey.core.camConfig import CamConfig


@pytest.fixture
def mock_dependencies(mocker):
    """Mocks all external, slow, or complex dependencies."""
    # Mock the audio sync function to return predictable start times
    mocker.patch(
        'ammonkey.core.sync.SyncAud.sync_videos',
        return_value={
            'vid1': (None, None, 100),
            'vid2': (None, None, 110),
            'vid3': (None, None, 105),
            'vid4': (None, None, 95)
        }
    )
    # Mock the LED sync function to return a predictable start frame
    mocker.patch(
        'ammonkey.core.sync.SyncLED.find_start_frame',
        return_value=150
    )
    # Mock file-writing and processing functions that are not part of the test
    mocker.patch('ammonkey.core.sync.SyncAud.save_synced_waveforms')
    mocker.patch('ammonkey.core.sync.SyncLED.process_videos')
    mocker.patch('ammonkey.core.sync.CamConfig.batchSelectROIs')


class TestVidSynchronizer:
    """Groups tests for the VidSynchronizer class."""

    def test_initialization(self, exp_note_setup: Path):
        """Tests that the VidSynchronizer initializes correctly."""
        notes = ExpNote(exp_note_setup)
        cam_cfg = CamConfig()
        sync_cfg = SyncConfig(led_threshold=200)

        synchronizer = VidSynchronizer(notes, cam_cfg, sync_cfg)

        assert synchronizer.notes is notes
        assert synchronizer.cam_config is cam_cfg
        assert synchronizer.config.led_threshold == 200


        synchronizer = VidSynchronizer(notes, cam_cfg, sync_cfg)

        assert synchronizer.notes is notes
        assert synchronizer.cam_config is cam_cfg
        assert synchronizer.config.led_threshold == 200

    def test_sync_all_happy_path(self, exp_note_setup: Path, mock_dependencies):
        return
        """
        Tests the entire syncAll workflow from detection to sync completion.
        This is the main "happy path" test.
        """
        notes = ExpNote(exp_note_setup)
        synchronizer = VidSynchronizer(notes)

        # Run the full synchronization process
        results = synchronizer.syncAll()

        # --- Assertions ---
        # 1. Check the results from the detection phase
        assert len(results) > 0
        first_result = results[0]
        assert first_result.status == 'success'
        assert "Cross-validation successful" in first_result.message
        assert first_result.config_path is not None
        assert first_result.config_path.exists()

        # 2. Check that detection and sync markers were created
        daet = first_result.daet
        sync_folder = notes.getDaetSyncRoot(daet)
        assert (sync_folder / '.skipDet').exists()

        # The sync process runs sequentially, so a .skipSync should also exist
        assert (sync_folder / '.skipSync').exists()

    def test_sync_all_skips_existing(self, exp_note_setup: Path, mocker):
        return
        """
        Tests that syncAll correctly skips DAETs that are already processed.
        """
        notes = ExpNote(exp_note_setup)
        # Manually create skip files for the first valid DAET
        daet_to_skip = notes.getValidDaets(min_videos=2)[0]
        sync_folder = notes.getDaetSyncRoot(daet_to_skip)
        sync_folder.mkdir(parents=True, exist_ok=True)
        (sync_folder / '.skipDet').touch()
        (sync_folder / '.skipSync').touch()

        # Spy on the methods that should NOT be called for the skipped DAET
        spy_led_sync = mocker.spy(VidSynchronizer, '_runLEDSync')
        spy_video_sync = mocker.spy(VidSynchronizer, '_runSyncForDaets')

        synchronizer = VidSynchronizer(notes)
        synchronizer.syncAll()

        # Assert that the spied methods were not called with the skipped DAET
        # We check that no call had daet_to_skip as its first argument
        assert daet_to_skip not in [call.args[1] for call in spy_led_sync.call_args_list]
        
        # We check that the list of daets passed to _runSyncForDaets does not contain our skipped daet
        for call in spy_video_sync.call_args_list:
            synced_daets_list = call.args[1]
            assert daet_to_skip not in synced_daets_list

    def test_cross_validation_logic(self, exp_note_setup: Path):
        """
        Directly tests the _crossValidate method with various scenarios.
        """
        notes = ExpNote(exp_note_setup)
        synchronizer = VidSynchronizer(notes)

        # Scenario 1: Good data, minor differences
        led = [150, 161, 154, 144]
        aud = [100, 110, 105, 95]
        corrected, status, msg = synchronizer._crossValidate(led, aud)
        assert status is None # Success
        assert corrected == [150, 161, 154, 144] # Median offset is 50
        assert "Cross-validation successful" in msg

        # Scenario 2: Missing LED data should be filled
        led_missing = [150, None, 155, None]
        aud_full = [100, 110, 105, 95]
        corrected, status, msg = synchronizer._crossValidate(led_missing, aud_full)
        assert status is None # Success
        assert corrected == [150, 160, 155, 145]
        assert "2 missing filled" in msg

        # Scenario 3: Too many deviations from audio sync
        led_bad = [150, 200, 155, 100] # 2nd and 4th are way off
        aud_ok = [100, 110, 105, 95]
        corrected, status, msg = synchronizer._crossValidate(led_bad, aud_ok)
        assert status == -2 # Failure
        assert corrected is None
        assert "Too many deviations" in msg

    def test_task_filtering(self, exp_note_setup: Path, mock_dependencies):
        """Tests that syncAll correctly filters by the specified task."""
        notes = ExpNote(exp_note_setup)
        synchronizer = VidSynchronizer(notes)

        # Run sync only for the BBT task
        results = synchronizer.syncAll(task=Task.BBT)

        # Assert that only one result was processed (the BBT one from our mock excel)
        assert len(results) == 1
        assert results[0].daet.task_type == Task.BBT