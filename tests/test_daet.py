# generated by gemini

import pytest
import pandas as pd
from ammonkey.core.daet import DAET, Task # Assuming 'daet.py' is in a package named 'ammonkey'

# A fixture provides a baseline DAET object for multiple tests, reducing code repetition.
@pytest.fixture
def sample_daet() -> DAET:
    """Provides a standard DAET object for testing."""
    return DAET(date='20250728', animal='Pici', experiment='BRKM', task='1')

class TestDAET:
    """Groups all tests related to the DAET class."""

    def test_creation_and_attributes(self, sample_daet):
        """Tests basic object creation and attribute access."""
        assert sample_daet.date == '20250728'
        assert sample_daet.animal == 'Pici'
        assert sample_daet.experiment == 'BRKM'
        assert sample_daet.task == '1'

    def test_invalid_date_format_raises_error(self):
        """Tests that __post_init__ validation catches bad date formats."""
        with pytest.raises(ValueError, match="Invalid date format: 28-07-2025"):
            DAET(date='28-07-2025', animal='Pici', experiment='TS', task='1')

    def test_string_representation(self, sample_daet):
        """Tests the __str__ and d property methods."""
        expected_str = '20250728-Pici-BRKM-1'
        assert str(sample_daet) == expected_str
        assert sample_daet.d == expected_str

    def test_official_representation(self, sample_daet):
        """Tests the __repr__ method."""
        assert repr(sample_daet) == "DAET('20250728-Pici-BRKM-1')"

    def test_equality(self, sample_daet):
        """Tests object equality logic."""
        daet1 = DAET('20250728', 'Pici', 'BRKM', '1')
        daet2 = DAET('20250729', 'Pici', 'BRKM', '1') # Different date
        assert sample_daet == daet1
        assert sample_daet != daet2
        assert sample_daet != "not a DAET object"

    def test_hashability(self, sample_daet):
        """Tests that DAET objects can be hashed for use in sets and dicts."""
        daet_copy = DAET('20250728', 'Pici', 'BRKM', '1')
        daet_set = {sample_daet, daet_copy}
        # The set should only contain one item because the two objects are equal
        assert len(daet_set) == 1
        assert hash(sample_daet) == hash(daet_copy)

    def test_info_property(self, sample_daet):
        """Tests the multi-line info string property."""
        info = sample_daet.info
        assert 'Date:       20250728' in info
        assert 'Animal:     Pici' in info
        assert 'Experiment: BRKM' in info
        assert 'Task:       1' in info

    def test_year_property(self, sample_daet):
        """Tests that the year is correctly extracted from the date."""
        assert sample_daet.year == 2025

    def test_isCalib_property(self):
        """Tests the calibration check property."""
        calib_daet = DAET('20250728', 'Pici', 'Pre-calib', '1')
        non_calib_daet = DAET('20250728', 'Pici', 'TS', '1')
        assert calib_daet.isCalib is True
        assert non_calib_daet.isCalib is False

    def test_from_row_classmethod(self):
        """Tests creating a DAET from a pandas Series."""
        row_data = pd.Series({'Experiment': '  TS  ', 'Task': ' 2 '})
        daet = DAET.fromRow(row_data, date='20250403', animal='Morty')
        # fromRow should strip whitespace
        assert daet.experiment == 'TS'
        assert daet.task == '2'
        assert daet.date == '20250403'
        assert daet.animal == 'Morty'

    # Use parametrize to test many cases with one test function
    @pytest.mark.parametrize("input_str, expected", [
        ('20250403-Pici-TS-1', DAET('20250403', 'Pici', 'TS', '1')),
        ('20250403-Pici-Some-Long-Experiment-1', DAET('20250403', 'Pici', 'Some-Long-Experiment', '1')),
    ])
    def test_from_string_valid(self, input_str, expected):
        """Tests valid cases for the fromString classmethod."""
        assert DAET.fromString(input_str) == expected

    def test_from_string_invalid(self):
        """Tests that fromString raises an error for invalid formats."""
        with pytest.raises(ValueError, match="Invalid DAET format"):
            DAET.fromString('20250403-Pici-TS') # Not enough parts

    @pytest.mark.parametrize("experiment_str, expected_task", [
        ('some_bbt_test', Task.BBT),
        ('BRKM_day1', Task.BRKM),
        ('brnk test', Task.BRKM), # Misspelling
        ('a puul test', Task.PULL), # Misspelling
        ('touch screen task', Task.TS),
        ('daily calib', Task.CALIB),
        ('An experiment with TS in it', Task.TS),
        ('unknown_experiment', None),
    ])
    def test_task_type_property(self, experiment_str, expected_task):
        """Tests the logic for identifying the task type from the experiment string."""
        daet = DAET('20250728', 'Pici', experiment_str, '1')
        assert daet.task_type is expected_task